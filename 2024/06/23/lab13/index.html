<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/cr32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/cr16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"Available values":"tabs | buttons","style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="背景知识编码器—解码器（seq2seq）在自然语言处理的很多应用中，输入和输出都可以是不定长序列。以机器翻译为例，输入可以是一段不定长的英语文本序列，输出可以是一段不定长的法语文本序列，例如  英语输入：“They”、“are”、“watching”、“.”   法语输出：“Ils”、“regardent”、“.”  当输入和输出都是不定长序列时，我们可以使用编码器—解码器（encoder-dec">
<meta property="og:type" content="article">
<meta property="og:title" content="机器翻译">
<meta property="og:url" content="http://example.com/2024/06/23/lab13/index.html">
<meta property="og:site_name" content="Lilin">
<meta property="og:description" content="背景知识编码器—解码器（seq2seq）在自然语言处理的很多应用中，输入和输出都可以是不定长序列。以机器翻译为例，输入可以是一段不定长的英语文本序列，输出可以是一段不定长的法语文本序列，例如  英语输入：“They”、“are”、“watching”、“.”   法语输出：“Ils”、“regardent”、“.”  当输入和输出都是不定长序列时，我们可以使用编码器—解码器（encoder-dec">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/10.9_seq2seq.svg?raw=true">
<meta property="og:image" content="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/10.10_s2s_prob1.svg?raw=true">
<meta property="og:image" content="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/10.10_s2s_prob2.svg?raw=true">
<meta property="og:image" content="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/10.10_beam_search.svg?raw=true">
<meta property="og:image" content="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/10.11_attention.svg?raw=true">
<meta property="og:image" content="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/lab13-2.png?raw=true">
<meta property="og:image" content="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/lab13-3.png?raw=true">
<meta property="og:image" content="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/lab13-4.png?raw=true">
<meta property="og:image" content="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/lab13-5.png?raw=true">
<meta property="og:image" content="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/lab13-6.png?raw=true">
<meta property="og:image" content="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/lab13-7.png?raw=true">
<meta property="og:image" content="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/lab13-8.png?raw=true">
<meta property="og:image" content="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/lab13-9.png?raw=true">
<meta property="article:published_time" content="2024-06-23T15:00:00.000Z">
<meta property="article:modified_time" content="2024-06-24T02:07:36.130Z">
<meta property="article:author" content="闲云">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/10.9_seq2seq.svg?raw=true">

<link rel="canonical" href="http://example.com/2024/06/23/lab13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>机器翻译 | Lilin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lilin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/23/lab13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Christina.jpg">
      <meta itemprop="name" content="闲云">
      <meta itemprop="description" content="雄关漫道真如铁 而今迈步从头越">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lilin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          机器翻译
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-23 23:00:00" itemprop="dateCreated datePublished" datetime="2024-06-23T23:00:00+08:00">2024-06-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-24 10:07:36" itemprop="dateModified" datetime="2024-06-24T10:07:36+08:00">2024-06-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Deep-Learning/" itemprop="url" rel="index"><span itemprop="name">Deep Learning</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="编码器—解码器（seq2seq）"><a href="#编码器—解码器（seq2seq）" class="headerlink" title="编码器—解码器（seq2seq）"></a>编码器—解码器（seq2seq）</h2><p>在自然语言处理的很多应用中，输入和输出都可以是不定长序列。以机器翻译为例，输入可以是一段不定长的英语文本序列，输出可以是一段不定长的法语文本序列，例如</p>
<blockquote>
<p>英语输入：“They”、“are”、“watching”、“.”</p>
</blockquote>
<blockquote>
<p>法语输出：“Ils”、“regardent”、“.”</p>
</blockquote>
<p>当输入和输出都是不定长序列时，我们可以使用编码器—解码器（encoder-decoder） 或者seq2seq模型。这两个模型本质上都用到了两个循环神经网络，分别叫做编码器和解码器。编码器用来分析输入序列，解码器用来生成输出序列。<span id="more"></span></p>
<p>图10.8描述了使用编码器—解码器将上述英语句子翻译成法语句子的一种方法。在训练数据集中，我们可以在每个句子后附上特殊符号“&lt;eos&gt;”（end of sequence）以表示序列的终止。编码器每个时间步的输入依次为英语句子中的单词、标点和特殊符号“&lt;eos&gt;”。图10.8中使用了编码器在最终时间步的隐藏状态作为输入句子的表征或编码信息。解码器在各个时间步中使用输入句子的编码信息和上个时间步的输出以及隐藏状态作为输入。我们希望解码器在各个时间步能正确依次输出翻译后的法语单词、标点和特殊符号”&lt;eos&gt;”。需要注意的是，解码器在最初时间步的输入用到了一个表示序列开始的特殊符号”&lt;bos&gt;”（beginning of sequence）。</p>
<div align="center">
<img width="500" src="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/10.9_seq2seq.svg?raw=true">
</div>
<div align="center">图10.8 使用编码器—解码器将句子由英语翻译成法语。编码器和解码器分别为循环神经网络</div>


<p>接下来，我们分别介绍编码器和解码器的定义。</p>
<h3 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h3><p>编码器的作用是把一个不定长的输入序列变换成一个定长的背景变量$\boldsymbol{c}$，并在该背景变量中编码输入序列信息。常用的编码器是循环神经网络。</p>
<p>让我们考虑批量大小为1的时序数据样本。假设输入序列是$x_1,\ldots,x_T$，例如$x_i$是输入句子中的第$i$个词。在时间步$t$，循环神经网络将输入$x_t$的特征向量$\boldsymbol{x_t}$和上个时间步的隐藏状态$\boldsymbol{h}_{t-1}$变换为当前时间步的隐藏状态$\boldsymbol{h}_t$。我们可以用函数$f$表达循环神经网络隐藏层的变换：</p>
<p>$$\boldsymbol{h_t} &#x3D; f(\boldsymbol{x_t}, \boldsymbol{h}_{t-1})$$</p>
<p>接下来，编码器通过自定义函数$q$将各个时间步的隐藏状态变换为背景变量</p>
<p>$$<br>\boldsymbol{c} &#x3D;  q(\boldsymbol{h}_1, \ldots, \boldsymbol{h}_T).<br>$$</p>
<p>例如，当选择$q(\boldsymbol{h}_1, \ldots, \boldsymbol{h}_T) &#x3D; \boldsymbol{h}_T$时，背景变量是输入序列最终时间步的隐藏状态$\boldsymbol{h}_T$。</p>
<p>以上描述的编码器是一个单向的循环神经网络，每个时间步的隐藏状态只取决于该时间步及之前的输入子序列。我们也可以使用双向循环神经网络构造编码器。在这种情况下，编码器每个时间步的隐藏状态同时取决于该时间步之前和之后的子序列（包括当前时间步的输入），并编码了整个序列的信息。</p>
<h3 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h3><p>刚刚已经介绍，编码器输出的背景变量$\boldsymbol{c}$编码了整个输入序列$x_1, \ldots, x_T$的信息。给定训练样本中的输出序列$y_1, y_2, \ldots, y_{T’}$，对每个时间步$t’$（符号与输入序列或编码器的时间步$t$有区别），解码器输出$y_{t’}$的条件概率将基于之前的输出序列$y_1,\ldots,y_{t’-1}$和背景变量$\boldsymbol{c}$，即$P(y_{t’} \mid y_1, \ldots, y_{t’-1}, \boldsymbol{c})$。</p>
<p>为此，我们可以使用另一个循环神经网络作为解码器。在输出序列的时间步$t^\prime$，解码器将上一时间步的输出$y_{t^\prime-1}$以及背景变量$\boldsymbol{c}$作为输入，并将它们与上一时间步的隐藏状态$\boldsymbol{s_{t^\prime-1}}$变换为当前时间步的隐藏状态$\boldsymbol{s}_{t^\prime}$。因此，我们可以用函数$g$表达解码器隐藏层的变换：</p>
<p>$$<br>\boldsymbol{s_{t^\prime}} &#x3D; g(y_{t^\prime-1}, \boldsymbol{c}, \boldsymbol{s}_{t^\prime-1}).<br>$$</p>
<p>有了解码器的隐藏状态后，我们可以使用自定义的输出层和softmax运算来计算$P(y_{t^\prime} \mid y_1, \ldots, y_{t^\prime-1}, \boldsymbol{c})$，例如，基于当前时间步的解码器隐藏状态 $\boldsymbol{s}_ {t^\prime}$、上一时间步的输出$y_{t^\prime-1}$以及背景变量$\boldsymbol{c}$来计算当前时间步输出$y_{t^\prime}$的概率分布。</p>
<h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><p>根据最大似然估计，我们可以最大化输出序列基于输入序列的条件概率</p>
<p>$$<br>\begin{aligned}<br>P(y_1, \ldots, y_{T’} \mid x_1, \ldots, x_T)<br>&amp;&#x3D; \prod_{t’&#x3D;1}^{T’} P(y_{t’} \mid y_1, \ldots, y_{t’-1}, x_1, \ldots, x_T)\\<br>&amp;&#x3D; \prod_{t’&#x3D;1}^{T’} P(y_{t’} \mid y_1, \ldots, y_{t’-1}, \boldsymbol{c}),<br>\end{aligned}<br>$$</p>
<p>并得到该输出序列的损失</p>
<p>$$<br>-\log P(y_1, \ldots, y_{T’} \mid x_1, \ldots, x_T) &#x3D; -\sum_{t’&#x3D;1}^{T’} \log P(y_{t’} \mid y_1, \ldots, y_{t’-1}, \boldsymbol{c}),<br>$$</p>
<p>在模型训练中，所有输出序列损失的均值通常作为需要最小化的损失函数。在图10.8所描述的模型预测中，我们需要将解码器在上一个时间步的输出作为当前时间步的输入。与此不同，在训练中我们也可以将标签序列（训练集的真实输出序列）在上一个时间步的标签作为解码器在当前时间步的输入。这叫作强制教学（teacher forcing）。</p>
<h2 id="束搜索"><a href="#束搜索" class="headerlink" title="束搜索"></a>束搜索</h2><p>上一节介绍了如何训练输入和输出均为不定长序列的编码器—解码器。本节我们介绍如何使用编码器—解码器来预测不定长的序列。</p>
<p>上一节里已经提到，在准备训练数据集时，我们通常会在样本的输入序列和输出序列后面分别附上一个特殊符号”&lt;eos&gt;”表示序列的终止。我们在接下来的讨论中也将沿用上一节的全部数学符号。为了便于讨论，假设解码器的输出是一段文本序列。设输出文本词典$\mathcal{Y}$（包含特殊符号”&lt;eos&gt;”）的大小为$\left|\mathcal{Y}\right|$，输出序列的最大长度为$T’$。所有可能的输出序列一共有$\mathcal{O}(\left|\mathcal{Y}\right|^{T’})$种。这些输出序列中所有特殊符号”&lt;eos&gt;”后面的子序列将被舍弃。</p>
<h3 id="贪婪搜索"><a href="#贪婪搜索" class="headerlink" title="贪婪搜索"></a>贪婪搜索</h3><p>让我们先来看一个简单的解决方案：贪婪搜索（greedy search）。对于输出序列任一时间步$t’$，我们从$|\mathcal{Y}|$个词中搜索出条件概率最大的词</p>
<p>$$<br>y _ { t ^ { \prime } } &#x3D; \underset { y \in \mathcal { Y } } { \operatorname { argmax } } P \left( y | y _ { 1 } , \ldots , y _ { t ^ { \prime } - 1 } , c \right)<br>$$</p>
<p>作为输出。一旦搜索出”&lt;eos&gt;”符号，或者输出序列长度已经达到了最大长度$T’$，便完成输出。</p>
<p>我们在描述解码器时提到，基于输入序列生成输出序列的条件概率是$\prod_{t’&#x3D;1}^{T’} P(y_{t’} \mid y_1, \ldots, y_{t’-1}, \boldsymbol{c})$。我们将该条件概率最大的输出序列称为最优输出序列。而贪婪搜索的主要问题是不能保证得到最优输出序列。</p>
<p>下面来看一个例子。假设输出词典里面有“A”“B”“C”和“&lt;eos&gt;”这4个词。图10.9中每个时间步下的4个数字分别代表了该时间步生成“A”“B”“C”和“&lt;eos&gt;”这4个词的条件概率。在每个时间步，贪婪搜索选取条件概率最大的词。因此，图10.9中将生成输出序列“A”“B”“C”“&lt;eos&gt;”。该输出序列的条件概率是$0.5\times0.4\times0.4\times0.6 &#x3D; 0.048$。</p>
<div align="center">
<img width="200" src="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/10.10_s2s_prob1.svg?raw=true">
</div>
<div align="center">图10.9 在每个时间步，贪婪搜索选取条件概率最大的词</div>


<p>接下来，观察图10.10演示的例子。与图10.9中不同，图10.10在时间步2中选取了条件概率第二大的词“C”。由于时间步3所基于的时间步1和2的输出子序列由图10.9中的“A”“B”变为了图10.10中的“A”“C”，图10.10中时间步3生成各个词的条件概率发生了变化。我们选取条件概率最大的词“B”。此时时间步4所基于的前3个时间步的输出子序列为“A”“C”“B”，与图10.9中的“A”“B”“C”不同。因此，图10.10中时间步4生成各个词的条件概率也与图10.9中的不同。我们发现，此时的输出序列“A”“C”“B”“&lt;eos&gt;”的条件概率是$0.5\times0.3\times0.6\times0.6&#x3D;0.054$，大于贪婪搜索得到的输出序列的条件概率。因此，贪婪搜索得到的输出序列“A”“B”“C”“&lt;eos&gt;”并非最优输出序列。</p>
<div align="center">
<img width="200" src="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/10.10_s2s_prob2.svg?raw=true">
</div>
<div align="center">图10.10 在时间步2选取条件概率第二大的词“C”</div>


<h3 id="穷举搜索"><a href="#穷举搜索" class="headerlink" title="穷举搜索"></a>穷举搜索</h3><p>如果目标是得到最优输出序列，我们可以考虑穷举搜索（exhaustive search）：穷举所有可能的输出序列，输出条件概率最大的序列。</p>
<p>虽然穷举搜索可以得到最优输出序列，但它的计算开销$\mathcal{O}(\left|\mathcal{Y}\right|^{T’})$很容易过大。例如，当$|\mathcal{Y}|&#x3D;10000$且$T’&#x3D;10$时，我们将评估$10000^{10} &#x3D; 10^{40}$个序列：这几乎不可能完成。而贪婪搜索的计算开销是$\mathcal{O}(\left|\mathcal{Y}\right|T’)$，通常显著小于穷举搜索的计算开销。例如，当$|\mathcal{Y}|&#x3D;10000$且$T’&#x3D;10$时，我们只需评估$10000\times10&#x3D;10^5$个序列。</p>
<h3 id="束搜索-1"><a href="#束搜索-1" class="headerlink" title="束搜索"></a>束搜索</h3><p>束搜索（beam search）是对贪婪搜索的一个改进算法。它有一个束宽（beam size）超参数。我们将它设为$k$。在时间步1时，选取当前时间步条件概率最大的$k$个词，分别组成$k$个候选输出序列的首词。在之后的每个时间步，基于上个时间步的$k$个候选输出序列，从$k\left|\mathcal{Y}\right|$个可能的输出序列中选取条件概率最大的$k$个，作为该时间步的候选输出序列。最终，我们从各个时间步的候选输出序列中筛选出包含特殊符号“&lt;eos&gt;”的序列，并将它们中所有特殊符号“&lt;eos&gt;”后面的子序列舍弃，得到最终候选输出序列的集合。</p>
<div align="center">
<img width="500" src="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/10.10_beam_search.svg?raw=true">
</div>
<div align="center">图10.11 束搜索的过程。束宽为2，输出序列最大长度为3。候选输出序列有A、C、AB、CE、ABD和CED</div>

<p>图10.11通过一个例子演示了束搜索的过程。假设输出序列的词典中只包含5个元素，即$\mathcal{Y} &#x3D; {A, B, C, D, E}$，且其中一个为特殊符号“&lt;eos&gt;”。设束搜索的束宽等于2，输出序列最大长度为3。在输出序列的时间步1时，假设条件概率$P(y_1 \mid \boldsymbol{c})$最大的2个词为$A$和$C$。我们在时间步2时将对所有的$y_2 \in \mathcal{Y}$都分别计算$P(y_2 \mid A, \boldsymbol{c})$和$P(y_2 \mid C, \boldsymbol{c})$，并从计算出的10个条件概率中取最大的2个，假设为$P(B \mid A, \boldsymbol{c})$和$P(E \mid C, \boldsymbol{c})$。那么，我们在时间步3时将对所有的$y_3 \in \mathcal{Y}$都分别计算$P(y_3 \mid A, B, \boldsymbol{c})$和$P(y_3 \mid C, E, \boldsymbol{c})$，并从计算出的10个条件概率中取最大的2个，假设为$P(D \mid A, B, \boldsymbol{c})$和$P(D \mid C, E, \boldsymbol{c})$。如此一来，我们得到6个候选输出序列：（1）$A$；（2）$C$；（3）$A$、$B$；（4）$C$、$E$；（5）$A$、$B$、$D$和（6）$C$、$E$、$D$。接下来，我们将根据这6个序列得出最终候选输出序列的集合。</p>
<p>在最终候选输出序列的集合中，我们取以下分数最高的序列作为输出序列：</p>
<p>$$ \frac{1}{L^\alpha} \log P(y_1, \ldots, y_{L}) &#x3D; \frac{1}{L^\alpha} \sum_{t’&#x3D;1}^L \log P(y_{t’} \mid y_1, \ldots, y_{t’-1}, \boldsymbol{c}),$$</p>
<p>其中$L$为最终候选序列长度，$\alpha$一般可选为0.75。分母上的$L^\alpha$是为了惩罚较长序列在以上分数中较多的对数相加项。分析可知，束搜索的计算开销为$\mathcal{O}(k\left|\mathcal{Y}\right|T’)$。这介于贪婪搜索和穷举搜索的计算开销之间。此外，贪婪搜索可看作是束宽为1的束搜索。束搜索通过灵活的束宽$k$来权衡计算开销和搜索质量。</p>
<h2 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h2><p>在编码器—解码器（seq2seq）里，解码器在各个时间步依赖相同的背景变量来获取输入序列信息。当编码器为循环神经网络时，背景变量来自它最终时间步的隐藏状态。</p>
<p>现在，让我们再次思考那一节提到的翻译例子：输入为英语序列“They”“are”“watching”“.”，输出为法语序列“Ils”“regardent”“.”。不难想到，解码器在生成输出序列中的每一个词时可能只需利用输入序列某一部分的信息。例如，在输出序列的时间步1，解码器可以主要依赖“They”“are”的信息来生成“Ils”，在时间步2则主要使用来自“watching”的编码信息生成“regardent”，最后在时间步3则直接映射句号“.”。这看上去就像是在解码器的每一时间步对输入序列中不同时间步的表征或编码信息分配不同的注意力一样。这也是注意力机制的由来。</p>
<p>仍然以循环神经网络为例，注意力机制通过对编码器所有时间步的隐藏状态做加权平均来得到背景变量。解码器在每一时间步调整这些权重，即注意力权重，从而能够在不同时间步分别关注输入序列中的不同部分并编码进相应时间步的背景变量。本节我们将讨论注意力机制是怎么工作的。</p>
<p>$$\boldsymbol{s}_{t’} &#x3D; g(\boldsymbol{y}_{t’-1}, \boldsymbol{c}_{t’}, \boldsymbol{s}_{t’-1}).$$</p>
<p>这里的关键是如何计算背景变量$\boldsymbol{c}_{t’}$和如何利用它来更新隐藏状态$\boldsymbol{s}_{t’}$。下面将分别描述这两个关键点。</p>
<h3 id="计算背景变量"><a href="#计算背景变量" class="headerlink" title="计算背景变量"></a>计算背景变量</h3><p>我们先描述第一个关键点，即计算背景变量。图10.12描绘了注意力机制如何为解码器在时间步2计算背景变量。首先，函数$a$根据解码器在时间步1的隐藏状态和编码器在各个时间步的隐藏状态计算softmax运算的输入。softmax运算输出概率分布并对编码器各个时间步的隐藏状态做加权平均，从而得到背景变量。</p>
<div align="center">
<img width="500" src="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/10.11_attention.svg?raw=true">
</div>
<div align="center">图10.12 编码器—解码器上的注意力机制</div>


<p>具体来说，令编码器在时间步$t$的隐藏状态为$\boldsymbol{h}_t$，且总时间步数为$T$。那么解码器在时间步$t’$的背景变量为所有编码器隐藏状态的加权平均：</p>
<p>$$<br>\boldsymbol{c}_{t’} &#x3D; \sum_{t&#x3D;1}^T \alpha_{t’t} \boldsymbol{h}_t,<br>$$</p>
<p>其中给定$t’$时，权重$\alpha_{t’ t}$在$t&#x3D;1,\ldots,T$的值是一个概率分布。为了得到概率分布，我们可以使用softmax运算:</p>
<p>$$<br>\alpha_{t’ t} &#x3D; \frac{\exp(e_{t’ t})}{ \sum_{k&#x3D;1}^T \exp(e_{t’ k}) },\quad t&#x3D;1,\ldots,T.<br>$$</p>
<p>现在，我们需要定义如何计算上式中softmax运算的输入$e_{t’ t}$。由于$e_{t’ t}$同时取决于解码器的时间步$t’$和编码器的时间步$t$，我们不妨以解码器在时间步$t’-1$的隐藏状态$\boldsymbol{s}_{t’ - 1}$与编码器在时间步$t$的隐藏状态$\boldsymbol{h}_t$为输入，并通过函数$a$计算$e_{t’ t}$：</p>
<p>$$<br>e_{t’ t} &#x3D; a(\boldsymbol{s}_{t’ - 1}, \boldsymbol{h}_t).<br>$$</p>
<p>这里函数$a$有多种选择，如果两个输入向量长度相同，一个简单的选择是计算它们的内积$a(\boldsymbol{s}, \boldsymbol{h})&#x3D;\boldsymbol{s}^\top \boldsymbol{h}$。而最早提出注意力机制的论文则将输入连结后通过含单隐藏层的多层感知机变换 ：</p>
<p>$$<br>a(\boldsymbol{s}, \boldsymbol{h}) &#x3D; \boldsymbol{v}^\top \tanh(\boldsymbol{W}_s \boldsymbol{s} + \boldsymbol{W}_h \boldsymbol{h}),<br>$$</p>
<p>其中$\boldsymbol{v}$、$\boldsymbol{W}_s$、$\boldsymbol{W}_h$都是可以学习的模型参数。</p>
<h4 id="矢量化计算"><a href="#矢量化计算" class="headerlink" title="矢量化计算"></a>矢量化计算</h4><p>我们还可以对注意力机制采用更高效的矢量化计算。广义上，注意力机制的输入包括查询项以及一一对应的键项和值项，其中值项是需要加权平均的一组项。在加权平均中，值项的权重来自查询项以及与该值项对应的键项的计算。</p>
<p>在上面的例子中，查询项为解码器的隐藏状态，键项和值项均为编码器的隐藏状态。<br>让我们考虑一个常见的简单情形，即编码器和解码器的隐藏单元个数均为$h$，且函数$a(\boldsymbol{s}, \boldsymbol{h})&#x3D;\boldsymbol{s}^\top \boldsymbol{h}$。假设我们希望根据解码器单个隐藏状态$\boldsymbol{s}_{t’ - 1} \in \mathbb{R}^{h}$和编码器所有隐藏状态$\boldsymbol{h}_t \in \mathbb{R}^{h}, t &#x3D; 1,\ldots,T$来计算背景向量$\boldsymbol{c}_{t’}\in \mathbb{R}^{h}$。<br>我们可以将查询项矩阵$\boldsymbol{Q} \in \mathbb{R}^{1 \times h}$设为$\boldsymbol{s}_{t’ - 1}^\top$，并令键项矩阵$\boldsymbol{K} \in \mathbb{R}^{T \times h}$和值项矩阵$\boldsymbol{V} \in \mathbb{R}^{T \times h}$相同且第$t$行均为$\boldsymbol{h}_t^\top$。此时，我们只需要通过矢量化计算</p>
<p>$$\text{softmax}(\boldsymbol{Q}\boldsymbol{K}^\top)\boldsymbol{V}$$</p>
<p>即可算出转置后的背景向量$\boldsymbol{c}_{t’}^\top$。当查询项矩阵$\boldsymbol{Q}$的行数为$n$时，上式将得到$n$行的输出矩阵。输出矩阵与查询项矩阵在相同行上一一对应。</p>
<h3 id="更新隐藏状态"><a href="#更新隐藏状态" class="headerlink" title="更新隐藏状态"></a>更新隐藏状态</h3><p>现在我们描述第二个关键点，即更新隐藏状态。以门控循环单元为例，在解码器中我们可以对6.7节（门控循环单元（GRU））中门控循环单元的设计稍作修改，从而变换上一时间步$t’-1$的输出$\boldsymbol{y}_{t’-1}$、隐藏状态$\boldsymbol{s}_{t’ - 1}$和当前时间步$t’$的含注意力机制的背景变量$\boldsymbol{c}_{t’}$ 。解码器在时间步$t’$的隐藏状态为</p>
<p>$$\boldsymbol{s}_{t’} &#x3D; \boldsymbol{z}_{t’} \odot \boldsymbol{s}_{t’-1}  + (1 - \boldsymbol{z}_{t’}) \odot \tilde{\boldsymbol{s}}_{t’},$$</p>
<p>其中的重置门、更新门和候选隐藏状态分别为</p>
<p>$$<br>\begin{aligned}<br>\boldsymbol{r}_{t’} &amp;&#x3D; \sigma(\boldsymbol{W}_{yr} \boldsymbol{y}_{t’-1} + \boldsymbol{W}_{sr} \boldsymbol{s}_{t’ - 1} + \boldsymbol{W}_{cr} \boldsymbol{c}_{t’} + \boldsymbol{b}_r),\\<br>\boldsymbol{z}_{t’} &amp;&#x3D; \sigma(\boldsymbol{W}_{yz} \boldsymbol{y}_{t’-1} + \boldsymbol{W}_{sz} \boldsymbol{s}_{t’ - 1} + \boldsymbol{W}_{cz} \boldsymbol{c}_{t’} + \boldsymbol{b}_z),\\<br>\tilde{\boldsymbol{s}}_{t’} &amp;&#x3D; \text{tanh}(\boldsymbol{W}_{ys} \boldsymbol{y}_{t’-1} + \boldsymbol{W}_{ss} (\boldsymbol{s}_{t’ - 1} \odot \boldsymbol{r}_{t’}) + \boldsymbol{W}_{cs} \boldsymbol{c}_{t’} + \boldsymbol{b}_s),<br>\end{aligned}<br>$$</p>
<p>其中含下标的$\boldsymbol{W}$和$\boldsymbol{b}$分别为门控循环单元的权重参数和偏差参数。</p>
<h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><p>本质上，注意力机制能够为表征中较有价值的部分分配较多的计算资源。这个有趣的想法自提出后得到了快速发展，特别是启发了依靠注意力机制来编码输入序列并解码出输出序列的变换器（Transformer）模型的设计 。变换器抛弃了卷积神经网络和循环神经网络的架构。它在计算效率上比基于循环神经网络的编码器—解码器模型通常更具明显优势。含注意力机制的变换器的编码结构在后来的BERT预训练模型中得以应用并令后者大放异彩：微调后的模型在多达11项自然语言处理任务中取得了当时最先进的结果 。不久后，同样是基于变换器设计的GPT-2模型于新收集的语料数据集预训练后，在7个未参与训练的语言模型数据集上均取得了当时最先进的结果 。除了自然语言处理领域，注意力机制还被广泛用于图像分类、自动图像描述、唇语解读以及语音识别。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="读取和预处理数据"><a href="#读取和预处理数据" class="headerlink" title="读取和预处理数据"></a>读取和预处理数据</h2><p>我们先定义一些特殊符号。其中“&lt;pad&gt;”（padding）符号用来添加在较短序列后，直到每个序列等长，而“&lt;bos&gt;”和“&lt;eos&gt;”符号分别表示序列的开始和结束。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torchtext.vocab <span class="keyword">as</span> Vocab</span><br><span class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> Data</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># sys.path.append(&quot;..&quot;) </span></span><br><span class="line"><span class="keyword">import</span> d2lzh_pytorch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">PAD, BOS, EOS = <span class="string">&#x27;&lt;pad&gt;&#x27;</span>, <span class="string">&#x27;&lt;bos&gt;&#x27;</span>, <span class="string">&#x27;&lt;eos&gt;&#x27;</span></span><br><span class="line">os.environ[<span class="string">&quot;CUDA_VISIBLE_DEVICES&quot;</span>] = <span class="string">&quot;0&quot;</span></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(torch.__version__, device)</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/lab13-2.png?raw=true" alt="alt text"></p>
<p>接着定义两个辅助函数对后面读取的数据进行预处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将一个序列中所有的词记录在all_tokens中以便之后构造词典，然后在该序列后面添加PAD直到序列</span></span><br><span class="line"><span class="comment"># 长度变为max_seq_len，然后将序列保存在all_seqs中</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_one_seq</span>(<span class="params">seq_tokens, all_tokens, all_seqs, max_seq_len</span>):</span><br><span class="line">    all_tokens.extend(seq_tokens)</span><br><span class="line">    seq_tokens += [EOS] + [PAD] * (max_seq_len - <span class="built_in">len</span>(seq_tokens) - <span class="number">1</span>)</span><br><span class="line">    all_seqs.append(seq_tokens)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用所有的词来构造词典。并将所有序列中的词变换为词索引后构造Tensor</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_data</span>(<span class="params">all_tokens, all_seqs</span>):</span><br><span class="line">    vocab = Vocab.Vocab(collections.Counter(all_tokens),</span><br><span class="line">                        specials=[PAD, BOS, EOS])</span><br><span class="line">    indices = [[vocab.stoi[w] <span class="keyword">for</span> w <span class="keyword">in</span> seq] <span class="keyword">for</span> seq <span class="keyword">in</span> all_seqs]</span><br><span class="line">    <span class="keyword">return</span> vocab, torch.tensor(indices)</span><br></pre></td></tr></table></figure>
<p>为了演示方便，我们在这里使用一个很小的法语—英语数据集。在这个数据集里，每一行是一对法语句子和它对应的英语句子，中间使用<code>&#39;\t&#39;</code>隔开。在读取数据时，我们在句末附上“&lt;eos&gt;”符号，并可能通过添加“&lt;pad&gt;”符号使每个序列的长度均为<code>max_seq_len</code>。我们为法语词和英语词分别创建词典。法语词的索引和英语词的索引相互独立。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_data</span>(<span class="params">max_seq_len</span>):</span><br><span class="line">    <span class="comment"># in和out分别是input和output的缩写</span></span><br><span class="line">    in_tokens, out_tokens, in_seqs, out_seqs = [], [], [], []</span><br><span class="line">    <span class="keyword">with</span> io.<span class="built_in">open</span>(<span class="string">&#x27;fr-en-small.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        in_seq, out_seq = line.rstrip().split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        in_seq_tokens, out_seq_tokens = in_seq.split(<span class="string">&#x27; &#x27;</span>), out_seq.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span>(<span class="built_in">len</span>(in_seq_tokens), <span class="built_in">len</span>(out_seq_tokens)) &gt; max_seq_len - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span>  <span class="comment"># 如果加上EOS后长于max_seq_len，则忽略掉此样本</span></span><br><span class="line">        process_one_seq(in_seq_tokens, in_tokens, in_seqs, max_seq_len)</span><br><span class="line">        process_one_seq(out_seq_tokens, out_tokens, out_seqs, max_seq_len)</span><br><span class="line">    in_vocab, in_data = build_data(in_tokens, in_seqs)</span><br><span class="line">    out_vocab, out_data = build_data(out_tokens, out_seqs)</span><br><span class="line">    <span class="keyword">return</span> in_vocab, out_vocab, Data.TensorDataset(in_data, out_data)</span><br></pre></td></tr></table></figure>
<p>将序列的最大长度设成7，然后查看读取到的第一个样本。该样本分别包含法语词索引序列和英语词索引序列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">max_seq_len = <span class="number">7</span></span><br><span class="line">in_vocab, out_vocab, dataset = read_data(max_seq_len)</span><br><span class="line">dataset[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/lab13-3.png?raw=true" alt="alt text"></p>
<h2 id="含注意力机制的编码器—解码器"><a href="#含注意力机制的编码器—解码器" class="headerlink" title="含注意力机制的编码器—解码器"></a>含注意力机制的编码器—解码器</h2><p>我们将使用含注意力机制的编码器—解码器来将一段简短的法语翻译成英语。下面我们来介绍模型的实现。</p>
<h3 id="编码器-1"><a href="#编码器-1" class="headerlink" title="编码器"></a>编码器</h3><p>在编码器中，我们将输入语言的词索引通过词嵌入层得到词的表征，然后输入到一个多层门控循环单元中。正如我们在6.5节（循环神经网络的简洁实现）中提到的，PyTorch的<code>nn.GRU</code>实例在前向计算后也会分别返回输出和最终时间步的多层隐藏状态。其中的输出指的是最后一层的隐藏层在各个时间步的隐藏状态，并不涉及输出层计算。注意力机制将这些输出作为键项和值项。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Encoder</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vocab_size, embed_size, num_hiddens, num_layers,</span></span><br><span class="line"><span class="params">                 drop_prob=<span class="number">0</span>, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(Encoder, self).__init__(**kwargs)</span><br><span class="line">        self.embedding = nn.Embedding(vocab_size, embed_size)</span><br><span class="line">        self.rnn = nn.GRU(embed_size, num_hiddens, num_layers, dropout=drop_prob)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, inputs, state</span>):</span><br><span class="line">        <span class="comment"># 输入形状是(批量大小, 时间步数)。将输出互换样本维和时间步维</span></span><br><span class="line">        embedding = self.embedding(inputs.long()).permute(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>) <span class="comment"># (seq_len, batch, input_size)</span></span><br><span class="line">        <span class="keyword">return</span> self.rnn(embedding, state)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">begin_state</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>下面我们来创建一个批量大小为4、时间步数为7的小批量序列输入。设门控循环单元的隐藏层个数为2，隐藏单元个数为16。编码器对该输入执行前向计算后返回的输出形状为(时间步数, 批量大小, 隐藏单元个数)。门控循环单元在最终时间步的多层隐藏状态的形状为(隐藏层个数, 批量大小, 隐藏单元个数)。对于门控循环单元来说，<code>state</code>就是一个元素，即隐藏状态；如果使用长短期记忆，<code>state</code>是一个元组，包含两个元素即隐藏状态和记忆细胞。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">encoder = Encoder(vocab_size=<span class="number">10</span>, embed_size=<span class="number">8</span>, num_hiddens=<span class="number">16</span>, num_layers=<span class="number">2</span>)</span><br><span class="line">output, state = encoder(torch.zeros((<span class="number">4</span>, <span class="number">7</span>)), encoder.begin_state())</span><br><span class="line">output.shape, state.shape <span class="comment"># GRU的state是h, 而LSTM的是一个元组(h, c)</span></span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/lab13-4.png?raw=true" alt="alt text"></p>
<h3 id="注意力机制-1"><a href="#注意力机制-1" class="headerlink" title="注意力机制"></a>注意力机制</h3><p>我们将实现注意力机制中定义的函数$a$：将输入连结后通过含单隐藏层的多层感知机变换。其中隐藏层的输入是解码器的隐藏状态与编码器在所有时间步上隐藏状态的一一连结，且使用tanh函数作为激活函数。输出层的输出个数为1。两个<code>Linear</code>实例均不使用偏差。其中函数$a$定义里向量$\boldsymbol{v}$的长度是一个超参数，即<code>attention_size</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">attention_model</span>(<span class="params">input_size, attention_size</span>):</span><br><span class="line">    model = nn.Sequential(nn.Linear(input_size, attention_size, bias=<span class="literal">False</span>),</span><br><span class="line">                          nn.Tanh(),</span><br><span class="line">                          nn.Linear(attention_size, <span class="number">1</span>, bias=<span class="literal">False</span>))</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>
<p>注意力机制的输入包括查询项、键项和值项。设编码器和解码器的隐藏单元个数相同。这里的查询项为解码器在上一时间步的隐藏状态，形状为(批量大小, 隐藏单元个数)；键项和值项均为编码器在所有时间步的隐藏状态，形状为(时间步数, 批量大小, 隐藏单元个数)。注意力机制返回当前时间步的背景变量，形状为(批量大小, 隐藏单元个数)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">attention_forward</span>(<span class="params">model, enc_states, dec_state</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    enc_states: (时间步数, 批量大小, 隐藏单元个数)</span></span><br><span class="line"><span class="string">    dec_state: (批量大小, 隐藏单元个数)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 将解码器隐藏状态广播到和编码器隐藏状态形状相同后进行连结</span></span><br><span class="line">    dec_states = dec_state.unsqueeze(dim=<span class="number">0</span>).expand_as(enc_states)</span><br><span class="line">    enc_and_dec_states = torch.cat((enc_states, dec_states), dim=<span class="number">2</span>)</span><br><span class="line">    e = model(enc_and_dec_states)  <span class="comment"># 形状为(时间步数, 批量大小, 1)</span></span><br><span class="line">    alpha = F.softmax(e, dim=<span class="number">0</span>)  <span class="comment"># 在时间步维度做softmax运算</span></span><br><span class="line">    <span class="keyword">return</span> (alpha * enc_states).<span class="built_in">sum</span>(dim=<span class="number">0</span>)  <span class="comment"># 返回背景变量</span></span><br></pre></td></tr></table></figure>
<p>在下面的例子中，编码器的时间步数为10，批量大小为4，编码器和解码器的隐藏单元个数均为8。注意力机制返回一个小批量的背景向量，每个背景向量的长度等于编码器的隐藏单元个数。因此输出的形状为(4, 8)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">seq_len, batch_size, num_hiddens = <span class="number">10</span>, <span class="number">4</span>, <span class="number">8</span></span><br><span class="line">model = attention_model(<span class="number">2</span>*num_hiddens, <span class="number">10</span>) </span><br><span class="line">enc_states = torch.zeros((seq_len, batch_size, num_hiddens))</span><br><span class="line">dec_state = torch.zeros((batch_size, num_hiddens))</span><br><span class="line">attention_forward(model, enc_states, dec_state).shape</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/lab13-5.png?raw=true" alt="alt text"></p>
<h3 id="含注意力机制的解码器"><a href="#含注意力机制的解码器" class="headerlink" title="含注意力机制的解码器"></a>含注意力机制的解码器</h3><p>我们直接将编码器在最终时间步的隐藏状态作为解码器的初始隐藏状态。这要求编码器和解码器的循环神经网络使用相同的隐藏层个数和隐藏单元个数。</p>
<p>在解码器的前向计算中，我们先通过刚刚介绍的注意力机制计算得到当前时间步的背景向量。由于解码器的输入来自输出语言的词索引，我们将输入通过词嵌入层得到表征，然后和背景向量在特征维连结。我们将连结后的结果与上一时间步的隐藏状态通过门控循环单元计算出当前时间步的输出与隐藏状态。最后，我们将输出通过全连接层变换为有关各个输出词的预测，形状为(批量大小, 输出词典大小)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Decoder</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vocab_size, embed_size, num_hiddens, num_layers,</span></span><br><span class="line"><span class="params">                 attention_size, drop_prob=<span class="number">0</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(Decoder, self).__init__()</span><br><span class="line">        self.embedding = nn.Embedding(vocab_size, embed_size)</span><br><span class="line">        self.attention = attention_model(<span class="number">2</span>*num_hiddens, attention_size)</span><br><span class="line">        <span class="comment"># GRU的输入包含attention输出的c和实际输入, 所以尺寸是 num_hiddens+embed_size</span></span><br><span class="line">        self.rnn = nn.GRU(num_hiddens + embed_size, num_hiddens, </span><br><span class="line">                          num_layers, dropout=drop_prob)</span><br><span class="line">        self.out = nn.Linear(num_hiddens, vocab_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, cur_input, state, enc_states</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        cur_input shape: (batch, )</span></span><br><span class="line"><span class="string">        state shape: (num_layers, batch, num_hiddens)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 使用注意力机制计算背景向量</span></span><br><span class="line">        c = attention_forward(self.attention, enc_states, state[-<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 将嵌入后的输入和背景向量在特征维连结, (批量大小, num_hiddens+embed_size)</span></span><br><span class="line">        input_and_c = torch.cat((self.embedding(cur_input), c), dim=<span class="number">1</span>) </span><br><span class="line">        <span class="comment"># 为输入和背景向量的连结增加时间步维，时间步个数为1</span></span><br><span class="line">        output, state = self.rnn(input_and_c.unsqueeze(<span class="number">0</span>), state)</span><br><span class="line">        <span class="comment"># 移除时间步维，输出形状为(批量大小, 输出词典大小)</span></span><br><span class="line">        output = self.out(output).squeeze(dim=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> output, state</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">begin_state</span>(<span class="params">self, enc_state</span>):</span><br><span class="line">        <span class="comment"># 直接将编码器最终时间步的隐藏状态作为解码器的初始隐藏状态</span></span><br><span class="line">        <span class="keyword">return</span> enc_state</span><br></pre></td></tr></table></figure>
<h2 id="训练模型-1"><a href="#训练模型-1" class="headerlink" title="训练模型"></a>训练模型</h2><p>我们先实现<code>batch_loss</code>函数计算一个小批量的损失。解码器在最初时间步的输入是特殊字符<code>BOS</code>。之后，解码器在某时间步的输入为样本输出序列在上一时间步的词，即强制教学。我们在这里用掩码变量避免填充项对损失函数计算的影响。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">batch_loss</span>(<span class="params">encoder, decoder, X, Y, loss</span>):</span><br><span class="line">    batch_size = X.shape[<span class="number">0</span>]</span><br><span class="line">    enc_state = encoder.begin_state()</span><br><span class="line">    enc_outputs, enc_state = encoder(X, enc_state)</span><br><span class="line">    <span class="comment"># 初始化解码器的隐藏状态</span></span><br><span class="line">    dec_state = decoder.begin_state(enc_state)</span><br><span class="line">    <span class="comment"># 解码器在最初时间步的输入是BOS</span></span><br><span class="line">    dec_input = torch.tensor([out_vocab.stoi[BOS]] * batch_size)</span><br><span class="line">    <span class="comment"># 我们将使用掩码变量mask来忽略掉标签为填充项PAD的损失, 初始全1</span></span><br><span class="line">    mask, num_not_pad_tokens = torch.ones(batch_size,), <span class="number">0</span></span><br><span class="line">    l = torch.tensor([<span class="number">0.0</span>])</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> Y.permute(<span class="number">1</span>,<span class="number">0</span>): <span class="comment"># Y shape: (batch, seq_len)</span></span><br><span class="line">        dec_output, dec_state = decoder(dec_input, dec_state, enc_outputs)</span><br><span class="line">        l = l + (mask * loss(dec_output, y)).<span class="built_in">sum</span>()</span><br><span class="line">        dec_input = y  <span class="comment"># 使用强制教学</span></span><br><span class="line">        num_not_pad_tokens += mask.<span class="built_in">sum</span>().item()</span><br><span class="line">        <span class="comment"># EOS后面全是PAD. 下面一行保证一旦遇到EOS接下来的循环中mask就一直是0</span></span><br><span class="line">        mask = mask * (y != out_vocab.stoi[EOS]).<span class="built_in">float</span>()</span><br><span class="line">    <span class="keyword">return</span> l / num_not_pad_tokens</span><br></pre></td></tr></table></figure>
<p>在训练函数中，我们需要同时迭代编码器和解码器的模型参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">encoder, decoder, dataset, lr, batch_size, num_epochs</span>):</span><br><span class="line">    enc_optimizer = torch.optim.Adam(encoder.parameters(), lr=lr)</span><br><span class="line">    dec_optimizer = torch.optim.Adam(decoder.parameters(), lr=lr)</span><br><span class="line"></span><br><span class="line">    loss = nn.CrossEntropyLoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">    data_iter = Data.DataLoader(dataset, batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        l_sum = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> X, Y <span class="keyword">in</span> data_iter:</span><br><span class="line">            enc_optimizer.zero_grad()</span><br><span class="line">            dec_optimizer.zero_grad()</span><br><span class="line">            l = batch_loss(encoder, decoder, X, Y, loss)</span><br><span class="line">            l.backward()</span><br><span class="line">            enc_optimizer.step()</span><br><span class="line">            dec_optimizer.step()</span><br><span class="line">            l_sum += l.item()</span><br><span class="line">        <span class="keyword">if</span> (epoch + <span class="number">1</span>) % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;epoch %d, loss %.3f&quot;</span> % (epoch + <span class="number">1</span>, l_sum / <span class="built_in">len</span>(data_iter)))</span><br></pre></td></tr></table></figure>
<p>接下来，创建模型实例并设置超参数。然后，我们就可以训练模型了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">embed_size, num_hiddens, num_layers = <span class="number">64</span>, <span class="number">64</span>, <span class="number">2</span></span><br><span class="line">attention_size, drop_prob, lr, batch_size, num_epochs = <span class="number">10</span>, <span class="number">0.5</span>, <span class="number">0.01</span>, <span class="number">2</span>, <span class="number">50</span></span><br><span class="line">encoder = Encoder(<span class="built_in">len</span>(in_vocab), embed_size, num_hiddens, num_layers,</span><br><span class="line">                  drop_prob)</span><br><span class="line">decoder = Decoder(<span class="built_in">len</span>(out_vocab), embed_size, num_hiddens, num_layers,</span><br><span class="line">                  attention_size, drop_prob)</span><br><span class="line">train(encoder, decoder, dataset, lr, batch_size, num_epochs)</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/lab13-6.png?raw=true" alt="alt text"></p>
<h2 id="预测不定长的序列"><a href="#预测不定长的序列" class="headerlink" title="预测不定长的序列"></a>预测不定长的序列</h2><p>在束搜索中我们介绍了3种方法来生成解码器在每个时间步的输出。这里我们实现最简单的贪婪搜索。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">translate</span>(<span class="params">encoder, decoder, input_seq, max_seq_len</span>):</span><br><span class="line">    in_tokens = input_seq.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    in_tokens += [EOS] + [PAD] * (max_seq_len - <span class="built_in">len</span>(in_tokens) - <span class="number">1</span>)</span><br><span class="line">    enc_input = torch.tensor([[in_vocab.stoi[tk] <span class="keyword">for</span> tk <span class="keyword">in</span> in_tokens]]) <span class="comment"># batch=1</span></span><br><span class="line">    enc_state = encoder.begin_state()</span><br><span class="line">    enc_output, enc_state = encoder(enc_input, enc_state)</span><br><span class="line">    dec_input = torch.tensor([out_vocab.stoi[BOS]])</span><br><span class="line">    dec_state = decoder.begin_state(enc_state)</span><br><span class="line">    output_tokens = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_seq_len):</span><br><span class="line">        dec_output, dec_state = decoder(dec_input, dec_state, enc_output)</span><br><span class="line">        pred = dec_output.argmax(dim=<span class="number">1</span>)</span><br><span class="line">        pred_token = out_vocab.itos[<span class="built_in">int</span>(pred.item())]</span><br><span class="line">        <span class="keyword">if</span> pred_token == EOS:  <span class="comment"># 当任一时间步搜索出EOS时，输出序列即完成</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output_tokens.append(pred_token)</span><br><span class="line">            dec_input = pred</span><br><span class="line">    <span class="keyword">return</span> output_tokens</span><br></pre></td></tr></table></figure>
<p>简单测试一下模型。输入法语句子“ils regardent.”，翻译后的英语句子应该是“they are watching.”。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input_seq = <span class="string">&#x27;ils regardent .&#x27;</span></span><br><span class="line">translate(encoder, decoder, input_seq, max_seq_len)</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/lab13-7.png?raw=true" alt="alt text"></p>
<h2 id="评价翻译结果"><a href="#评价翻译结果" class="headerlink" title="评价翻译结果"></a>评价翻译结果</h2><p>评价机器翻译结果通常使用BLEU（Bilingual Evaluation Understudy）[1]。对于模型预测序列中任意的子序列，BLEU考察这个子序列是否出现在标签序列中。</p>
<p>具体来说，设词数为$n$的子序列的精度为$p_n$。它是预测序列与标签序列匹配词数为$n$的子序列的数量与预测序列中词数为$n$的子序列的数量之比。举个例子，假设标签序列为$A$、$B$、$C$、$D$、$E$、$F$，预测序列为$A$、$B$、$B$、$C$、$D$，那么$p_1 &#x3D; 4&#x2F;5, p_2 &#x3D; 3&#x2F;4, p_3 &#x3D; 1&#x2F;3, p_4 &#x3D; 0$。设$len_{\text{label}}$和$len_{\text{pred}}$分别为标签序列和预测序列的词数，那么，BLEU的定义为</p>
<p>$$ \exp\left(\min\left(0, 1 - \frac{len_{\text{label}}}{len_{\text{pred}}}\right)\right) \prod_{n&#x3D;1}^k p_n^{1&#x2F;2^n},$$</p>
<p>其中$k$是我们希望匹配的子序列的最大词数。可以看到当预测序列和标签序列完全一致时，BLEU为1。</p>
<p>因为匹配较长子序列比匹配较短子序列更难，BLEU对匹配较长子序列的精度赋予了更大权重。例如，当$p_n$固定在0.5时，随着$n$的增大，$0.5^{1&#x2F;2} \approx 0.7, 0.5^{1&#x2F;4} \approx 0.84, 0.5^{1&#x2F;8} \approx 0.92, 0.5^{1&#x2F;16} \approx 0.96$。另外，模型预测较短序列往往会得到较高$p_n$值。因此，上式中连乘项前面的系数是为了惩罚较短的输出而设的。举个例子，当$k&#x3D;2$时，假设标签序列为$A$、$B$、$C$、$D$、$E$、$F$，而预测序列为$A$、$B$。虽然$p_1 &#x3D; p_2 &#x3D; 1$，但惩罚系数$\exp(1-6&#x2F;2) \approx 0.14$，因此BLEU也接近0.14。</p>
<p>下面来实现BLEU的计算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bleu</span>(<span class="params">pred_tokens, label_tokens, k</span>):</span><br><span class="line">    len_pred, len_label = <span class="built_in">len</span>(pred_tokens), <span class="built_in">len</span>(label_tokens)</span><br><span class="line">    score = math.exp(<span class="built_in">min</span>(<span class="number">0</span>, <span class="number">1</span> - len_label / len_pred))</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k + <span class="number">1</span>):</span><br><span class="line">        num_matches, label_subs = <span class="number">0</span>, collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len_label - n + <span class="number">1</span>):</span><br><span class="line">            label_subs[<span class="string">&#x27;&#x27;</span>.join(label_tokens[i: i + n])] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len_pred - n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> label_subs[<span class="string">&#x27;&#x27;</span>.join(pred_tokens[i: i + n])] &gt; <span class="number">0</span>:</span><br><span class="line">                num_matches += <span class="number">1</span></span><br><span class="line">                label_subs[<span class="string">&#x27;&#x27;</span>.join(pred_tokens[i: i + n])] -= <span class="number">1</span></span><br><span class="line">        score *= math.<span class="built_in">pow</span>(num_matches / (len_pred - n + <span class="number">1</span>), math.<span class="built_in">pow</span>(<span class="number">0.5</span>, n))</span><br><span class="line">    <span class="keyword">return</span> score</span><br></pre></td></tr></table></figure>
<p>接下来，定义一个辅助打印函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">input_seq, label_seq, k</span>):</span><br><span class="line">    pred_tokens = translate(encoder, decoder, input_seq, max_seq_len)</span><br><span class="line">    label_tokens = label_seq.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;bleu %.3f, predict: %s&#x27;</span> % (bleu(pred_tokens, label_tokens, k),</span><br><span class="line">                                      <span class="string">&#x27; &#x27;</span>.join(pred_tokens)))</span><br></pre></td></tr></table></figure>
<p>预测正确则分数为1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">score(<span class="string">&#x27;ils regardent .&#x27;</span>, <span class="string">&#x27;they are watching .&#x27;</span>, k=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/lab13-8.png?raw=true" alt="alt text"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">score(<span class="string">&#x27;ils sont canadienne .&#x27;</span>, <span class="string">&#x27;they are canadian .&#x27;</span>, k=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/KianaMeiZaychik/KianaMeiZaychik.github.io/blob/master/photo/lab13-9.png?raw=true" alt="alt text"></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/06/19/HM24-6-19/" rel="prev" title="2025武忠详高数辅导讲义严选题无穷级数第二题第三项的反例">
      <i class="fa fa-chevron-left"></i> 2025武忠详高数辅导讲义严选题无穷级数第二题第三项的反例
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/06/24/lab14/" rel="next" title="基于transformer和pytorch的中日机器翻译模型">
      基于transformer和pytorch的中日机器翻译模型 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">背景知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8%E2%80%94%E8%A7%A3%E7%A0%81%E5%99%A8%EF%BC%88seq2seq%EF%BC%89"><span class="nav-number">1.1.</span> <span class="nav-text">编码器—解码器（seq2seq）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8"><span class="nav-number">1.1.1.</span> <span class="nav-text">编码器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-number">1.1.2.</span> <span class="nav-text">解码器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.3.</span> <span class="nav-text">训练模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%9F%E6%90%9C%E7%B4%A2"><span class="nav-number">1.2.</span> <span class="nav-text">束搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%A9%AA%E6%90%9C%E7%B4%A2"><span class="nav-number">1.2.1.</span> <span class="nav-text">贪婪搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%B7%E4%B8%BE%E6%90%9C%E7%B4%A2"><span class="nav-number">1.2.2.</span> <span class="nav-text">穷举搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%9F%E6%90%9C%E7%B4%A2-1"><span class="nav-number">1.2.3.</span> <span class="nav-text">束搜索</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6"><span class="nav-number">1.3.</span> <span class="nav-text">注意力机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E8%83%8C%E6%99%AF%E5%8F%98%E9%87%8F"><span class="nav-number">1.3.1.</span> <span class="nav-text">计算背景变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%A2%E9%87%8F%E5%8C%96%E8%AE%A1%E7%AE%97"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">矢量化计算</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E9%9A%90%E8%97%8F%E7%8A%B6%E6%80%81"><span class="nav-number">1.3.2.</span> <span class="nav-text">更新隐藏状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E5%B1%95"><span class="nav-number">1.3.3.</span> <span class="nav-text">发展</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.</span> <span class="nav-text">代码实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE"><span class="nav-number">2.1.</span> <span class="nav-text">读取和预处理数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AB%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E7%9A%84%E7%BC%96%E7%A0%81%E5%99%A8%E2%80%94%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-number">2.2.</span> <span class="nav-text">含注意力机制的编码器—解码器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">编码器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">注意力机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AB%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E7%9A%84%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-number">2.2.3.</span> <span class="nav-text">含注意力机制的解码器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B-1"><span class="nav-number">2.3.</span> <span class="nav-text">训练模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E6%B5%8B%E4%B8%8D%E5%AE%9A%E9%95%BF%E7%9A%84%E5%BA%8F%E5%88%97"><span class="nav-number">2.4.</span> <span class="nav-text">预测不定长的序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%84%E4%BB%B7%E7%BF%BB%E8%AF%91%E7%BB%93%E6%9E%9C"><span class="nav-number">2.5.</span> <span class="nav-text">评价翻译结果</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="闲云"
      src="/images/Christina.jpg">
  <p class="site-author-name" itemprop="name">闲云</p>
  <div class="site-description" itemprop="description">雄关漫道真如铁 而今迈步从头越</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">闲云</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">75k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:09</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>
        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


</body>
</html>
